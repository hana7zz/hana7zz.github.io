<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>MySQL笔记-1 | Hana.X</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL笔记-1</h1><a id="logo" href="/.">Hana.X</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL笔记-1</h1><div class="post-meta">2025-05-18<span> | </span><span class="category"><a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</a></span></div><div class="post-content"><ul>
<li><a href="#mysql%E8%AF%AD%E5%8F%A5">Mysql语句</a><ul>
<li><a href="#%E5%BA%93%E7%9B%B8%E5%85%B3">库相关</a></li>
<li><a href="#%E8%A1%A8%E7%9B%B8%E5%85%B3">表相关</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C">数据操作</a></li>
<li><a href="#%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2">单表查询</a></li>
<li><a href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2">多表查询</a></li>
<li><a href="#%E5%AD%90%E6%9F%A5%E8%AF%A2">子查询</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a><ul>
<li><a href="#%E6%95%B4%E5%9E%8B">整型</a></li>
<li><a href="#%E6%B5%AE%E7%82%B9%E5%9E%8B">浮点型</a></li>
<li><a href="#%E5%AE%9A%E7%82%B9%E6%95%B0decimal">定点数DECIMAL</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">枚举类型</a><ul>
<li><a href="#enum">ENUM</a></li>
<li><a href="#set">SET</a></li>
<li><a href="#set-%E4%B8%8E-enum-%E7%9A%84%E5%AF%B9%E6%AF%94">SET 与 ENUM 的对比</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B">时间类型</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">如何选择数据类型</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81">字符集编码</a><ul>
<li><a href="#%E4%B8%BB%E8%A6%81%E5%8F%98%E9%87%8F%E5%90%AB%E4%B9%89">主要变量含义</a></li>
</ul>
</li>
<li><a href="#%E5%88%97%E5%B1%9E%E6%80%A7%E5%AE%8C%E6%95%B4%E6%80%A7">列属性完整性</a><ul>
<li><a href="#%E4%B8%BB%E9%94%AE">主键</a></li>
<li><a href="#%E5%94%AF%E4%B8%80%E9%94%AE">唯一键</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7">数据库完整性</a></li>
<li><a href="#%E5%A4%96%E9%94%AE">外键</a><ul>
<li><a href="#%E7%BD%AE%E7%A9%BA%E5%92%8C%E7%BA%A7%E8%81%94">置空和级联</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4">数据库设计思维</a><ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li>
<li><a href="#%E5%AE%9E%E4%BD%93%E5%92%8C%E5%AE%9E%E4%BD%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">实体和实体之间的关系</a></li>
<li><a href="#codd%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F">Codd三大范式</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-1">小结</a></li>
</ul>
</li>
<li><a href="#%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86">高级部分</a><ul>
<li><a href="#%E8%A7%86%E5%9B%BE">视图</a><ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7">核心特性</a></li>
<li><a href="#%E4%BC%98%E7%82%B9">优点</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9">缺点</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E5%8A%A1">事务</a><ul>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7acid">事务的四大特性(ACID)</a></li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95">索引</a><ul>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
<li><a href="#%E4%BC%98%E7%82%B9-1">优点</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9">缺点</a></li>
<li><a href="#%E5%BA%94%E8%AF%A5%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%97%E6%AE%B5">应该创建索引的字段</a></li>
<li><a href="#%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5">不建议创建索引的情况</a></li>
</ul>
</li>
<li><a href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">存储过程</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a><ul>
<li><a href="#number%E7%9B%B8%E5%85%B3">Number相关</a></li>
<li><a href="#string%E7%9B%B8%E5%85%B3">String相关</a></li>
<li><a href="#others">Others</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BC%81%E4%B8%9A%E8%A7%84%E8%8C%83%E7%BA%A6%E6%9D%9F">企业规范约束</a><ul>
<li><a href="#%E5%BA%93%E8%A1%A8%E5%AD%97%E6%AE%B5%E7%BA%A6%E6%9D%9F%E8%A7%84%E8%8C%83">库表字段约束规范</a></li>
<li><a href="#sql%E5%BC%80%E5%8F%91%E7%BA%A6%E6%9D%9F">SQL开发约束</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E8%A7%84%E8%8C%83">索引规范</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
</ul>
<h1 id="Mysql语句"><a href="#Mysql语句" class="headerlink" title="Mysql语句"></a>Mysql语句</h1><h2 id="库相关"><a href="#库相关" class="headerlink" title="库相关"></a>库相关</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS database_name CHARACTER SET utf8mb4;</span><br><span class="line">DROP DATABASE IF EXISTS database_name;</span><br><span class="line">SHOW CREATE DATABASE database_name;</span><br><span class="line">ALTER DATABASE database_name CHARACTER SET utf8mb4;</span><br><span class="line">USE database_name;</span><br></pre></td></tr></table></figure>

<h2 id="表相关"><a href="#表相关" class="headerlink" title="表相关"></a>表相关</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">CREATE TABLE IF NOT EXISTS table_name (</span><br><span class="line">    column1 datatype [constraints] [COMMENT &#x27;column description&#x27;],</span><br><span class="line">    column2 datatype [constraints] [COMMENT &#x27;column description&#x27;],</span><br><span class="line">    ...</span><br><span class="line">	) ENGINE=InnoDB;</span><br><span class="line">SHOW CREATE TABLE table_name;</span><br><span class="line">DESC table_name;</span><br><span class="line">DROP TABLE IF EXISTS table_name;</span><br></pre></td></tr></table></figure>

<p>constraints包括但不限于：<strong>NOT NULL</strong>、<strong>PRIMARY KEY</strong> 、<strong>AUTO_INCREMENT</strong> 、<strong>DEFAULT</strong></p>
<p><strong>修改表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE old_table_name RENAME TO new_table_name; -- 修改表名</span><br><span class="line">ALTER TABLE table_name ADD column_name data_type [constraints]; -- 添加字段</span><br><span class="line">ALTER TABLE table_name DROP column_name; -- 删除字段</span><br><span class="line">ALTER TABLE table_name MODIFY column_name new_data_type; -- 修改字段的数据类型</span><br><span class="line">ALTER TABLE table_name CHANGE old_column new_column data_type; -- 重命名列(同时可修改类型)</span><br></pre></td></tr></table></figure>

<h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name (column1, column2, column3, ...)</span><br><span class="line">VALUES (value1, value2, value3, ...);</span><br><span class="line"></span><br><span class="line">DELETE FROM table_name WHERE condition;</span><br><span class="line">TRUNCATE TABLE table_name; -- 清空表</span><br><span class="line"></span><br><span class="line">UPDATE table_name</span><br><span class="line">SET column1 = value1, column2 = value2, ...</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DELETE FROM table_name</code>不建议使用，因为它跟for语句一样，把一个条数据删除，再把第二条数据删除..效率低。而且它会接着之前表中的id继续跑，所以想要清空表（报废整张表）时，使用<code>TRUNCATE</code>语句。</li>
</ul>
<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SELECT 2 * 3 AS alias_name FROM DUAL; -- DUAL是一个特殊的虚拟表，主要用于在没有实际表的情况下执行 SELECT语句</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	[DISTINCT | ALL] -- 默认是ALL, 即使不写</span><br><span class="line">    column1,</span><br><span class="line">    column2,</span><br><span class="line">    ... </span><br><span class="line">FROM </span><br><span class="line">    table_name</span><br><span class="line">[WHERE </span><br><span class="line">    condition]  -- 可用关键字: NOT, IN, BETWEEN AND, =, IS NULL, LIKE</span><br><span class="line">[GROUP BY </span><br><span class="line">    column_name(s) [ASC | DESC]] -- 查询的字段必须是被分组的字段和聚合函数</span><br><span class="line">[HAVING </span><br><span class="line">    condition] </span><br><span class="line">[ORDER BY </span><br><span class="line">    column_name(s) [ASC | DESC]]</span><br><span class="line">[LIMIT   -- LIMIT 10, 5; 跳过前 10 条，从第11条开始，获取5条记录。等价于 LIMIT 5 OFFSET 10;</span><br><span class="line">    offset, row_count]; </span><br></pre></td></tr></table></figure>

<p>聚合函数：<code>SUM()</code> <code>AVG()</code> <code>MAX()</code> <code>MIN()</code> <code>COUNT()</code> <code>GROUP_CONCAT</code></p>
<p>LIKE模糊查询：<code>%</code>  匹配任意数量的字符（包括零个字符）；<code>_</code>  匹配单个字符</p>
<p><strong>WHERE和HAVING：</strong></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>作用对象</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>WHERE</strong></td>
<td>原始数据表中的记录（行）</td>
<td>在数据<strong>分组之前</strong>筛选记录</td>
</tr>
<tr>
<td><strong>HAVING</strong></td>
<td>分组后的结果（GROUP BY 后的组）</td>
<td>在数据<strong>分组之后</strong>筛选组</td>
</tr>
</tbody></table>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    [DISTINCT] </span><br><span class="line">    t1.column1 [AS alias1],</span><br><span class="line">    t2.column2 [AS alias2],</span><br><span class="line">    ...</span><br><span class="line">FROM </span><br><span class="line">    primary_table t1</span><br><span class="line">[JOIN_TYPE] JOIN secondary_table t2 </span><br><span class="line">    ON t1.common_key = t2.common_key</span><br><span class="line">    [AND additional_conditions]</span><br><span class="line">[WHERE </span><br><span class="line">    filter_conditions]</span><br><span class="line">[GROUP BY </span><br><span class="line">    group_columns]</span><br><span class="line">[HAVING </span><br><span class="line">    group_filter]</span><br><span class="line">[ORDER BY </span><br><span class="line">    sort_columns [ASC|DESC]]</span><br><span class="line">[LIMIT </span><br><span class="line">    [offset,] row_count];</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">JOIN TYPE</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INNER JOIN</td>
<td>只返回匹配的行（默认）</td>
</tr>
<tr>
<td align="left">LEFT JOIN</td>
<td>返回左表所有行，右表无匹配则为NULL</td>
</tr>
<tr>
<td align="left">RIGHT JOIN</td>
<td>返回右表所有行，左表无匹配则为NULL</td>
</tr>
<tr>
<td align="left">CROSS JOIN</td>
<td>笛卡尔积（慎用）</td>
</tr>
<tr>
<td align="left">NATURAL JOIN</td>
<td>必须有至少一个同名字段，所有同名列都会被用于连接，无需写 ON 或 USING 子句。若同名字段大于等于2个，可使用USING。USING专门用于两个表具有相同列名的情况。无同名字段则返回笛卡尔积。</td>
</tr>
</tbody></table>
<p>在实际生产环境中，<strong>显式指定连接条件的标准连接方式</strong>是更可靠、更可维护的选择。说白了，就是<strong>写全</strong>，哪两张表进行连接？分别根据表中的什么字段进行的连接？连接的方式是什么？</p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>等于</td>
<td><code>WHERE price = (SELECT MAX(price)...)</code></td>
</tr>
<tr>
<td><code>IN</code></td>
<td>在列表中</td>
<td><code>WHERE id IN (SELECT id...)</code></td>
</tr>
<tr>
<td><code>NOT IN</code></td>
<td>不在列表中</td>
<td><code>WHERE id NOT IN (SELECT id...)</code></td>
</tr>
<tr>
<td><code>EXISTS</code></td>
<td>存在记录</td>
<td><code>WHERE EXISTS (SELECT 1...)</code></td>
</tr>
<tr>
<td><code>NOT EXISTS</code></td>
<td>不存在记录</td>
<td><code>WHERE NOT EXISTS (SELECT 1...)</code></td>
</tr>
</tbody></table>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><strong>DDL</strong>(Data Definition Language) 数据库定义语言：<code>CREATE</code> <code>ALTER</code> <code>DROP</code> <code>SHOW</code></li>
<li><strong>DML</strong>(Data Manipulation Language) 数据操纵语言 ：<code>INSERT</code> <code>UPDATE</code> <code>DELETE</code> <code>SELECT</code></li>
<li><strong>DCL</strong>(Data Control Language) 数据库控制语言</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><table>
<thead>
<tr>
<th>Type</th>
<th>Storage</th>
<th>Range(Signed)</th>
<th>Range(Unsigned)</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1 Byte</td>
<td>(-128，127)</td>
<td>(0，255)</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2 Bytes</td>
<td>(-32 768，32 767)</td>
<td>(0，65 535)</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3 Bytes</td>
<td>(-8 388 608，8 388 607)</td>
<td>(0，16 777 215)</td>
</tr>
<tr>
<td>INT</td>
<td>4 Bytes</td>
<td>(-2 147 483 648，2 147 483 647)</td>
<td>(0，4 294 967 295)</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8 Bytes</td>
<td>(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)</td>
<td>(0，18 446 744 073 709 551 615)</td>
</tr>
</tbody></table>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>存储空间</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT(M, D)</td>
<td>4 bytes</td>
<td>m总个数，d小数位</td>
</tr>
<tr>
<td>DOUBLE(M, D)</td>
<td>8 bytes</td>
<td>m总个数，d小数位</td>
</tr>
</tbody></table>
<p>MySQL中一般不会使用浮点类型。</p>
<h2 id="定点数DECIMAL"><a href="#定点数DECIMAL" class="headerlink" title="定点数DECIMAL"></a>定点数DECIMAL</h2><ul>
<li>高精度的数据类型，常用来存储交易相关的数据，FLOAT和DOUBLE都会在一定的程度上造成精度的丢失</li>
<li>DECIMAL(M,N).M代表总精度，N代表小数点右侧的位数（标度）</li>
<li>1 &lt; M &lt; 254, 0 &lt; N &lt; 60;</li>
<li>支持无符号</li>
<li>存储空间变大，整数部分和小数部分是分开存储的</li>
<li>算术运算比浮点类型慢</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><table>
<thead>
<tr>
<th>类型</th>
<th>单位</th>
<th>最大</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>字符</td>
<td>最大为255字符</td>
<td>存储定长，容易造成空间的浪费</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>字符</td>
<td>可以超过255个字符</td>
<td>存储变长，节省存储空间</td>
</tr>
<tr>
<td>TEXT</td>
<td>字节</td>
<td>总大小为65535字节，约为64KB</td>
<td>-</td>
</tr>
</tbody></table>
<ul>
<li><p>VARCHAR会回收多余的空间，例如如果定义了VARCHAR(20)时只使用了5个宽度，那么VARCHAR会回收多余的15个宽度的空间，但CHAR却不会</p>
</li>
<li><p>VARCHAR的效率会比CHAR低</p>
</li>
<li><p><code>VARCHAR()</code> 所占用的空间（字节数）跟字符数量和使用的<strong>字符编码</strong>有关</p>
<ul>
<li>使用不同字符编码的同一个字符，对应是不同的字节数</li>
</ul>
</li>
<li><p><code>VARCHAR(N)</code>中<strong>N指字符数</strong>（或宽度），不是字节数</p>
<ul>
<li>字符：<code>A</code>、<code>中</code>、<code>1</code>、<code>@</code>、<code>！</code> 都是字符</li>
</ul>
</li>
</ul>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h3 id="ENUM"><a href="#ENUM" class="headerlink" title="ENUM"></a>ENUM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENUM(&#x27;value1&#x27;, &#x27;value2&#x27;, ..., &#x27;valueN&#x27;)</span><br></pre></td></tr></table></figure>

<p>ENUM类型在数据库中实际上是以数值索引形式存储的，而非直接存储字符串值，系统会创建映射关系。</p>
<ol>
<li><p><strong>内部存储机制</strong>：</p>
<ul>
<li><p>每个ENUM值被分配一个整数索引（从1开始）</p>
</li>
<li><p>实际存储的是这个索引值而非字符串</p>
</li>
<li><p>例如：<code>ENUM(&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;)</code>存储为1&#x3D;red, 2&#x3D;green, 3&#x3D;blue</p>
</li>
</ul>
</li>
<li><p><strong>存储空间</strong>：</p>
<ul>
<li><p>1-255个枚举值：使用1字节存储（最大256个值）</p>
</li>
<li><p>256-65535个枚举值：使用2字节存储（理论上限65535个值）</p>
</li>
</ul>
</li>
<li><p><strong>好处</strong>：</p>
<ul>
<li><p>节省空间</p>
</li>
<li><p>索引效率高，速率快</p>
</li>
<li><p>限制数据，避免脏数据产生</p>
</li>
</ul>
</li>
</ol>
<h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET(&#x27;value1&#x27;, &#x27;value2&#x27;, ..., &#x27;value64&#x27;)</span><br></pre></td></tr></table></figure>

<p>SET 类型是 MySQL 中一种特殊的字符串类型，用于存储一组预定义的字符串值的组合。</p>
<ol>
<li><p><strong>存储原理</strong>：</p>
<ul>
<li><p>类似 ENUM 但允许多值组合</p>
</li>
<li><p>内部存储为位掩码（bitmask）数值</p>
</li>
<li><p>每个值对应一个比特位</p>
</li>
<li><p>最多可包含 64 个不同的成员值</p>
</li>
</ul>
</li>
<li><p><strong>存储空间</strong>：</p>
<ul>
<li>1-8 个成员：1 字节</li>
<li>9-16 个成员：2 字节</li>
<li>17-32 个成员：4 字节</li>
<li>33-64 个成员：8 字节</li>
</ul>
</li>
</ol>
<h3 id="SET-与-ENUM-的对比"><a href="#SET-与-ENUM-的对比" class="headerlink" title="SET 与 ENUM 的对比"></a>SET 与 ENUM 的对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>SET 类型</th>
<th>ENUM 类型</th>
</tr>
</thead>
<tbody><tr>
<td>存储内容</td>
<td><strong>多个</strong>值的组合</td>
<td><strong>单个</strong>值</td>
</tr>
<tr>
<td>成员数量</td>
<td>最多64个</td>
<td>最多65535个</td>
</tr>
<tr>
<td>存储效率</td>
<td>按位存储(1-8字节)</td>
<td>按索引存储(1-2字节)</td>
</tr>
<tr>
<td>典型用途</td>
<td>多选项属性</td>
<td>单选项属性</td>
</tr>
</tbody></table>
<h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>格式</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>3字节</td>
<td>YYYY-MM-DD</td>
<td>2015-05-01</td>
</tr>
<tr>
<td>TIME</td>
<td>3字节</td>
<td>HH:MM:SS</td>
<td>11:12:00</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8字节</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>2015-05-01 11:12:00</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4字节</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h2 id="如何选择数据类型"><a href="#如何选择数据类型" class="headerlink" title="如何选择数据类型"></a>如何选择数据类型</h2><p>关于字段的数据类型，<strong>没有一个统一的标准，但应该符合业务项目逻辑的标准。</strong></p>
<h1 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;character_set_%‘;</span><br><span class="line">SET character_set_client = gbk;</span><br><span class="line">SET character_set_results = gbk;</span><br></pre></td></tr></table></figure>

<h2 id="主要变量含义"><a href="#主要变量含义" class="headerlink" title="主要变量含义"></a>主要变量含义</h2><ol>
<li><strong>character_set_client</strong>：客户端发送查询使用的字符集</li>
<li><strong>character_set_connection</strong>：连接层使用的字符集</li>
<li><strong>character_set_database</strong>：默认数据库的字符集</li>
<li><strong>character_set_results</strong>：服务器返回结果使用的字符集</li>
<li><strong>character_set_server</strong>：服务器默认字符集</li>
<li><strong>character_set_system</strong>：系统元数据(表名等)存储使用的字符集(固定为utf8)</li>
</ol>
<p>在Windows上把<code>character_set_client</code>和<code>character_set_results</code>都改成gbk，基本上就可以插入中文数据。</p>
<p>实际开发过程中，必须一律为<strong>utf8mb4</strong>，符合国际标准。</p>
<h1 id="列属性完整性"><a href="#列属性完整性" class="headerlink" title="列属性完整性"></a>列属性完整性</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><ul>
<li>拥有主键(PRIMARY KEY)属性的数据<strong>不能为空</strong>，且<strong>数据值唯一</strong>，不能重复。主键通常作为<strong>唯一标识符</strong>。</li>
<li>主键可以作为其他表查询数据的依据，换句话说，<strong>主键与其他的表可能是有关联的</strong>。</li>
<li>主键不一定自增，但若自增，则其字段必须设置为主键。</li>
<li>若一张表中设置了主键，即使删除了某条数据，后来插入的数据也不能拥有之前被删掉的数据的主键。主键必须唯一，即使数据被删掉了。</li>
<li>一张表中<strong>只能有一个主键</strong>，但主键可以由多个字段组成，即复合主键。复合主键的一个用途：在业务逻辑中，id和name都不能重复时，可以设置复合主键。</li>
<li>如果主键设置了AUTO_INCREMENT，可以插入NULL的值；如果没有设置，则不能插入NULL。</li>
</ul>
<h2 id="唯一键"><a href="#唯一键" class="headerlink" title="唯一键"></a>唯一键</h2><ul>
<li>拥有唯一键（UNIQUE）属性的数据值可以为空，但数据值唯一，<strong>保证数据不重复</strong>。</li>
<li>唯一键只能在它所在的那张表中起作用，不与外界有关联。</li>
<li>一张表中可以有多个唯一键。</li>
</ul>
<h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><ol>
<li>保证有主键，在一张表中。即使没有主键，也应该设置唯一键去标识每一条数据。</li>
<li>保证合适的数据类型</li>
<li>保证合理的字段属性（是否设置主键，是否设置唯一键，是否设置能为空，若不能为空其默认值是什么）</li>
<li>考虑单表中的字段是否可能需要被外部的引用</li>
</ol>
<h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FOREIGN KEY (child_column) REFERENCES parent_table(parent_column)</span><br><span class="line">ON DELETE SET NULL</span><br><span class="line">ON UPDATE SET NULL</span><br><span class="line">ON DELETE CASCADE</span><br><span class="line">ON UPDATE CASCADE</span><br><span class="line"></span><br><span class="line">SHOW CREATE TABLE table_name; -- 只能通过这种方式查到外键约束</span><br><span class="line">ALTER TABLE table_name DROP FOREIGN KEY CONSTRAINT; -- 删除外键时，只能通过外键约束来删除，不能通过子表列名来删除</span><br></pre></td></tr></table></figure>

<ul>
<li>外键一般都在建表的时候设置好（以及置空和级联操作），不在后期添加更新上去。</li>
<li>在高并发集群项目中，<strong>禁止</strong>使用外键，极大地影响性能。</li>
</ul>
<h3 id="置空和级联"><a href="#置空和级联" class="headerlink" title="置空和级联"></a>置空和级联</h3><p><strong>置空：</strong>当父表数据被删除或主键修改时，子表中<strong>关联的外键字段会被自动设为</strong><code>NULL</code>，但子表记录本身仍然保留。</p>
<p><strong>级联：</strong>当父表数据被删除或主键修改时，子表中<strong>所有关联记录会自动同步删除或更新</strong>。</p>
<p>置空一般应用于<strong>删除数据</strong>（<code>ON DELETE SET NULL</code>），级联一般应用于<strong>更新数据</strong>（<code>ON UPDATE CASCADE</code>）。</p>
<h1 id="数据库设计思维"><a href="#数据库设计思维" class="headerlink" title="数据库设计思维"></a>数据库设计思维</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>关系型数据库：</strong>两张表的共有字段去确定数据的完整性。</p>
<p><strong>数据完整性</strong>：指保证组织的数据在其生命周期的任何阶段都是<strong>准确、完整和一致</strong>的。保持数据完整性需要保护组织的数据免遭丢失、泄露和破坏性影响。</p>
<p><strong>行：</strong>一条数据、一条数据记录、实体</p>
<p><strong>列：</strong>一个字段、属性</p>
<h2 id="实体和实体之间的关系"><a href="#实体和实体之间的关系" class="headerlink" title="实体和实体之间的关系"></a>实体和实体之间的关系</h2><p>即一条记录和一条记录之间的关系。一对一、一对多、多对多。</p>
<h2 id="Codd三大范式"><a href="#Codd三大范式" class="headerlink" title="Codd三大范式"></a>Codd三大范式</h2><ol>
<li><p><strong>确保每列原子性</strong></p>
<p>一个字段在定义的时候就不能再分割下去了，即列不能够再分成其他几列。但不是强制性的，需要<strong>统计</strong>的数据，其字段应该拆开。</p>
</li>
<li><p><strong>非键字段必须依赖于键字段</strong></p>
<p>说白了就是别他妈没事找事，不应该出现表中不应该出现的</p>
</li>
<li><p><strong>消除传递依赖</strong></p>
<p>一般情况下，不能出现数据冗余和多余的字段。</p>
</li>
</ol>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>根据业务项目的逻辑需求而设计，没有一个标准。</p>
<h1 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h1><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图（View）是 MySQL 中一种虚拟表，其内容由查询定义。视图并不实际存储数据，而是基于一个或多个基表（或其它视图）的查询结果集。类似函数，但不是函数。</p>
<h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ol>
<li><strong>虚拟表</strong>：不实际存储数据，只存储定义</li>
<li><strong>动态数据</strong>：数据随基表数据变化自动更新</li>
<li><strong>简化查询</strong>：封装复杂查询逻辑</li>
<li><strong>安全控制</strong>：限制用户访问基表的特定列或行，隐藏敏感信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 创建视图，命名为”vw_xxx“</span><br><span class="line">CREATE VIEW view_name AS</span><br><span class="line">SELECT column1, column2, ...</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE condition];</span><br><span class="line"></span><br><span class="line">SELECT * FROM view_name; -- 查询视图</span><br><span class="line">SHOW FULL TABLES WHERE table_type = &#x27;VIEW&#x27;; -- 查看已有视图</span><br><span class="line">SHOW CREATE VIEW view_name; -- 查看视图定义</span><br><span class="line">DESC view_name; -- 查看视图结构</span><br><span class="line">DROP VIEW IF EXISTS view_name; -- 删除视图</span><br><span class="line"></span><br><span class="line">-- 修改视图</span><br><span class="line">ALTER VIEW view_name AS</span><br><span class="line">SELECT ... FROM ...;</span><br><span class="line"></span><br><span class="line">-- 视图算法：MERGE(合并)、TEMPTABLE(临时表)、UNDEFINED(自动选择)</span><br><span class="line">-- 如果视图中包含子查询，要把视图算法设置为TEMPTABLE</span><br><span class="line">CREATE ALGORITHM = MERGE VIEW view_name AS ...;</span><br></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ol>
<li><strong>简化操作</strong>：隐藏复杂查询逻辑</li>
<li><strong>安全性</strong>：限制数据访问权限</li>
<li><strong>逻辑独立性</strong>：基表结构变化不影响应用</li>
<li><strong>数据一致性</strong>：保证统一的计算逻辑</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>性能问题</strong>：复杂视图可能影响查询性能</li>
<li><strong>更新限制</strong>：不是所有视图都支持更新操作</li>
<li><strong>维护成本</strong>：大量视图会增加数据库复杂度</li>
</ol>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION; -- 开始事务</span><br><span class="line">COMMIT; -- 提交事务</span><br><span class="line">ROLLBACK; -- 回滚事务</span><br><span class="line"></span><br><span class="line">-- 设置保存点</span><br><span class="line">SAVEPOINT savepoint_name;</span><br><span class="line">ROLLBACK TO savepoint_name;</span><br><span class="line">RELEASE SAVEPOINT savepoint_name; -- 删除保存点</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>从事务开启的一刹那，随时随地可以<code>ROLLBACK</code>，但一旦<code>COMMIT</code>就不能<code>ROLLBACK</code>了</li>
<li>只有使用<code>InnoDB</code>引擎的数据库，才能使用事务操作</li>
</ul>
<h3 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性(ACID)"></a>事务的四大特性(ACID)</h3><ol>
<li>**原子性(Atomicity)**：事务是不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚</li>
<li>**一致性(Consistency)**：事务执行前后，数据库从一个一致性状态变到另一个一致性状态</li>
<li>**隔离性(Isolation)**：多个事务并发执行时，一个事务的执行不应影响其他事务</li>
<li>**持久性(Durability)**：一旦事务提交，其所做的修改会永久保存在数据库中</li>
</ol>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是MySQL中用于提高查询性能的重要数据结构，它类似于书籍的目录，可以帮助数据库快速定位数据而不必扫描整个表。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><strong>普通索引</strong>：最基本的索引类型，无特殊限制</li>
<li><strong>唯一索引</strong>：确保索引列的值唯一，允许NULL值</li>
<li><strong>主键索引</strong>：特殊的唯一索引，不允许NULL值</li>
<li><strong>复合索引</strong>：多列组合的索引</li>
<li><strong>前缀索引</strong>：只对列的前N个字符建立索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name(column_name); -- 创建普通索引</span><br><span class="line">CREATE UNIQUE INDEX index_name ON table_name(column_name); -- 创建唯一索引</span><br><span class="line">DROP INDEX index_name ON table_name; -- 删除索引</span><br><span class="line"></span><br><span class="line">-- MySQL没有直接修改索引的命令，通常需要先删除旧索引再创建新索引</span><br><span class="line"></span><br><span class="line">-- 主键索引就是PRIMARY KEY</span><br><span class="line">ALTER TABLE table_name ADD PRIMARY KEY (column_name); -- 创建主键索引（通常在建表时指定）</span><br><span class="line">ALTER TABLE table_name DROP PRIMARY KEY; -- 删除主键</span><br></pre></td></tr></table></figure>

<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h3><ul>
<li>大幅提高查询速度</li>
<li>优化排序和分组：加速ORDER BY、GROUP BY操作</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ul>
<li>降低写操作性能：数据增删改的效率因需要维护索引而大幅降低</li>
<li>增加存储空间、维护成本</li>
</ul>
<h3 id="应该创建索引的字段"><a href="#应该创建索引的字段" class="headerlink" title="应该创建索引的字段"></a>应该创建索引的字段</h3><ol>
<li><strong>主键和外键字段</strong></li>
<li><strong>高频查询的字段</strong></li>
<li><strong>排序和分组字段</strong>：ORDER BY、GROUP BY、DISTINCT使用的列</li>
<li><strong>高选择性的列</strong>：唯一值比例高的列（如用户ID、手机号）</li>
</ol>
<h3 id="不建议创建索引的情况"><a href="#不建议创建索引的情况" class="headerlink" title="不建议创建索引的情况"></a>不建议创建索引的情况</h3><ol>
<li><strong>数据量小的表</strong>：全表扫描可能比索引扫描更快</li>
<li><strong>频繁更新的列</strong>：写性能影响大于读性能提升</li>
<li><strong>区分度低的列</strong>：如性别、状态等只有几个取值的列</li>
<li><strong>很少用于查询的列</strong>：不会被查询条件使用的列</li>
<li><strong>长文本字段</strong>：如TEXT&#x2F;BLOB类型，考虑使用前缀索引</li>
</ol>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>相当于SQL里的函数，只不过函数体需要我们自己写，内容也是SQL语句。一般情况，开发人员用不到，了解即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 创建存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE procedure_name([parameter_list])</span><br><span class="line">BEGIN</span><br><span class="line">    -- SQL statements</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程</span><br><span class="line">CALL procedure_name([parameter_list]);</span><br><span class="line">-- 查看存储过程定义</span><br><span class="line">SHOW CREATE PROCEDURE procedure_name;</span><br><span class="line">-- 删除存储过程</span><br><span class="line">DROP PROCEDURE IF EXISTS procedure_name;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="Number相关"><a href="#Number相关" class="headerlink" title="Number相关"></a>Number相关</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RAND()</td>
<td>生成随机数</td>
</tr>
<tr>
<td>ROUND()</td>
<td>四舍五入</td>
</tr>
<tr>
<td>CEIL()</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR()</td>
<td>向下取整</td>
</tr>
<tr>
<td>TRUNCATE(X, D)</td>
<td>X：要截断的数字，D：要保留的小数位数</td>
</tr>
<tr>
<td>ORDER BY RAND()</td>
<td>随机排序</td>
</tr>
</tbody></table>
<h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>UCASE()</td>
<td>转大写</td>
</tr>
<tr>
<td>LCASE()</td>
<td>转小写</td>
</tr>
<tr>
<td>LEFT(str, len)</td>
<td>从左截取</td>
</tr>
<tr>
<td>RIGHT(str, len)</td>
<td>从右截取</td>
</tr>
<tr>
<td>SUBSTRING(str, pos, len)</td>
<td>从某一位置截取</td>
</tr>
<tr>
<td>CONCAT(str1, str2, …)</td>
<td>拼接字符串</td>
</tr>
<tr>
<td>REPLACE(str, from_str, to_str)</td>
<td>替换字符串中的子串</td>
</tr>
</tbody></table>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NOW()</td>
<td>获取当前的时间</td>
</tr>
<tr>
<td>UNIX_TIMESTAMP()</td>
<td>获取时间戳</td>
</tr>
<tr>
<td>SHA()</td>
<td>哈希加密</td>
</tr>
</tbody></table>
<h1 id="企业规范约束"><a href="#企业规范约束" class="headerlink" title="企业规范约束"></a>企业规范约束</h1><h2 id="库表字段约束规范"><a href="#库表字段约束规范" class="headerlink" title="库表字段约束规范"></a>库表字段约束规范</h2><ol>
<li><p>如果某个字段表示的含义仅仅为<strong>是或否</strong>，则该字段的字段名必须以<strong>“is_”</strong>开头，例如is_active（是否激活）、is_admin（是否为管理员）、is_deleted（是否被删除）等，并且其数据类型必须为<strong>UNSIGNED TINYINT</strong>，长度必须为<strong>1</strong>。</p>
</li>
<li><p>表名和字段名必须全部<strong>小写字母</strong>，不能出现大写字母 ，且不能以数字开头。若含有多个单词，一定要用下划线隔开。两个下划线之间只出现数字也是不行的，例如“xx_1_xx”。表名的命名：<strong>不能出现复数</strong>。</p>
<p><em>尤其是关系型数据库，尤其是Mysql或SQL Server，一旦<strong>定义</strong>了字段就<strong>不能</strong>再改字段了，改字段非常麻烦，所付出的代价太大了。</em>所以在一开始设计数据库时，应该把表的结构达到结构统一化。开发人员在开发过程中，应该避免改动表的结构。</p>
</li>
<li><p>Mysql里的关键字不能应用于表名和字段名</p>
</li>
<li><p>索引名的命名：pk_xxx（主键索引名）、uk_xxx（唯一键索引名）、idx_xxx（普通索引名）</p>
</li>
<li><p>凡是有小数的数据，其数据类型禁止使用float和double，所有带小数的数据的数据类型一律使用<code>decimal</code>。</p>
</li>
<li><p>如果字符串的长度很短，则数据类型直接使用CHAR（定长字符串），不用VARCHAR；如果字符串的长度非常长（超过5000），则数据类型使用<code>TEXT</code>不用VARCHAR。</p>
</li>
<li><p>任何表中，都必须要有三个字段：id、create_time、update_time</p>
<p>id必须定义为<strong>UNSIGNED BIGINT</strong>类型 ，id必须为<strong>PRIMARY KEY</strong>。在单表（该id和其他表中的id不作为绑定的时候）中，主键必须自增，步长为1。</p>
<p>creat_time和update_time 必须为DATETIME类型。</p>
</li>
<li><p>数据冗余的问题</p>
<ul>
<li><p>定义：一个字段在多个表里重复出现。</p>
</li>
<li><p>应用：如果数据库的某些数据的被频繁的查询，应当添加“多余”的字段，允许适当的冗余。</p>
<p>例如，高考成绩查分时，总分这个数据被大量地，频繁地查询，应当设置总分这个字段。</p>
</li>
<li><p>优点：提高查询性能。缺点：消耗空间，增加成本，数据多不容易维护。</p>
</li>
</ul>
</li>
<li><p>根据实际情况合理地定义字段的数据类型和长度。例如，人的年龄是非负数且不超过200，所以其数据类型必须是<code>UNSIGNED TINYINT</code></p>
</li>
</ol>
<h2 id="SQL开发约束"><a href="#SQL开发约束" class="headerlink" title="SQL开发约束"></a>SQL开发约束</h2><ol>
<li><p>COUNT函数</p>
<ul>
<li><p><strong>COUNT(*)</strong> - 统计所有行数，包括 NULL 值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>COUNT(column_name)</strong> - 统计指定列非 NULL 值的行数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(column_name) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>COUNT(DISTINCT column_name)</strong> - 统计指定列去重后的非 NULL 值数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> column_name) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>COUNT(1)</strong> - 与 COUNT(*) 效果相同，统计所有行数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>性能比较</p>
<ul>
<li><code>COUNT(*)</code> 和 <code>COUNT(1)</code> 性能基本相同，现代 MySQL 优化器会以相同方式处理</li>
<li><code>COUNT(column_name)</code> 需要检查该列是否为 NULL，性能稍差</li>
<li><code>COUNT(DISTINCT column_name)</code> 性能最差，因为它需要去重操作</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>COUNT 返回的是 BIGINT 类型的值</li>
<li>在没有匹配行时返回 0 而不是 NULL</li>
<li>在 MyISAM 存储引擎中，COUNT(*) 非常快，因为行数被存储了</li>
<li>在 InnoDB 中，COUNT(*) 需要全表扫描或索引扫描</li>
</ul>
</li>
</ul>
</li>
<li><p>判断某条数据的某个字段是否为空，一定要用<code>ISNULL()</code>函数，切忌用<code>=</code>号（例如”name &#x3D; null”）</p>
</li>
<li><p>在高并发集群项目中，<strong>绝对不能使用外键和级联操作</strong>。因为一旦外键改了，其他的表也要跟着改。一切外键的问题都在应用层上解决，不能在SQL上用。</p>
</li>
<li><p>实际开发过程中，<strong>不允许使用存储过程</strong>。因为存储过程很难调试。如果一条SQL语句写错了，其他的执行了，这条没执行，就完蛋了，而且存储过程很难扩展。开发人员禁止使用存储过程。</p>
</li>
<li><p>若要删除某个数据，先<code>SELECT</code>一下，先查出来看有没有，确认有的话再删除。</p>
</li>
<li><p>子查询时，关于关键字<code>IN</code>的操作，尽量不要用，能不用就不用</p>
</li>
<li><p>项目的编码格式一律为<strong>utf8mb4</strong>。数据库客户端、数据库server、数据库接收端发送端的编码格式也一律为<strong>utf8mb4</strong>格式</p>
</li>
</ol>
<h2 id="索引规范"><a href="#索引规范" class="headerlink" title="索引规范"></a>索引规范</h2><ol>
<li>具有唯一特性的字段，即使它是多个字段的组合，也应该设置一个唯一索引。</li>
<li>项目上、业务上，应该要给唯一索引的，给其唯一索引。</li>
<li>如果在varchar上建立索引，必须指定索引的长度</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>只能<strong>两张表</strong>进行内连接，三张及以上的表之间不能进行内连接。如果连接 （join）的话，两张表关联的字段的数据类型<strong>必须一致</strong>。</li>
<li>多表关联查询的时候，关联查询的字段也应该要有索引。</li>
</ol>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul></div><div class="post-nav"><a class="next" href="/2025/05/14/my-struggle/">我的奋斗（罗永浩）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://hana7zz.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/hana.png"/></a><p>Keep it simple, stupid.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BD%B1%E8%AF%84/">影评</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/05/18/mysql-note1/">MySQL笔记-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/14/my-struggle/">我的奋斗（罗永浩）</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/12/Little-Miss-Sunshine/">阳光小美女</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/08/Man-Search-for-Meaning/">活出生命的意义</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Hana.X.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>